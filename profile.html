<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cosmic Dashboard</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Space+Grotesk:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="assets/profile.css">
</head>
<body>
  <div class="cosmic-bg"></div>
  <div class="nebula nebula-1"></div>
  <div class="nebula nebula-2"></div>
  <div class="nebula nebula-3"></div>
  
  <div class="stars" id="stars"></div>

  <div class="container">
    <header class="header">
      <div class="header-left">
        <h1>‚ú¶ Cosmic Dashboard</h1>
        <p>Navigate your learning cosmos</p>
      </div>
      <button class="logout-btn" onclick="logout()">Logout</button>
    </header>

    <div id="loading" class="loading">
      <div class="spinner"></div>
      <p>Loading your cosmic journey...</p>
    </div>

    <div id="content" style="display: none;">
      <section class="welcome-section">
        <h2>Welcome, <span id="user-name">Astronaut</span></h2>
        <p>Your stellar progress awaits</p>
      </section>

      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-icon">üöÄ</div>
          <h3>MODULE XP</h3>
          <div class="stat-value" id="module-xp">0</div>
          <p class="stat-label">Completed Projects</p>
        </div>

        <div class="stat-card">
          <div class="stat-icon">üìä</div>
          <h3>CURRENT LEVEL</h3>
          <div class="stat-value" id="current-level">0</div>
          <p class="stat-label">Progression Level</p>
        </div>

        <div class="stat-card">
          <div class="stat-icon">üéØ</div>
          <h3>AUDIT RATIO</h3>
          <div class="stat-value" id="audit-ratio">0.0</div>
          <p class="stat-label">Done / Received</p>
        </div>
      </div>

      <div class="chart-card">
        <div class="chart-header">
          <h2 class="chart-title">‚ú¶ XP Journey Timeline</h2>
          <p class="chart-subtitle">Your experience progression through space</p>
        </div>
        <svg id="line-chart" viewBox="0 0 900 350"></svg>
      </div>

      <div class="chart-card">
        <div class="chart-header">
          <h2 class="chart-title">üöÄ XP Earned Per Project</h2>
          <p class="chart-subtitle">Your top performing missions</p>
        </div>
        <svg id="bar-chart" viewBox="0 0 900 400"></svg>
      </div>

      <div class="chart-card">
        <div class="chart-header">
          <h2 class="chart-title">üï∏Ô∏è Skills Analysis</h2>
          <p class="chart-subtitle">Your technical abilities breakdown</p>
        </div>
        <div class="skills-grid">
          <div>
            <h3 style="text-align: center; color: #a78bfa; margin-bottom: 1rem;">Programming Languages</h3>
            <svg id="spider-lang" viewBox="0 0 400 400"></svg>
          </div>
          <div>
            <h3 style="text-align: center; color: #ec4899; margin-bottom: 1rem;">Technical Skills</h3>
            <svg id="spider-tech" viewBox="0 0 400 400"></svg>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="tooltip" id="tooltip"></div>

  <script>
    let jwt = sessionStorage.getItem("jwt");
    if (!jwt) window.location.href = "index.html";
    jwt = jwt.trim().replace(/^["']|["']$/g, '');

    const API = "https://learn.reboot01.com/api/graphql-engine/v1/graphql";
    const tooltip = document.getElementById("tooltip");

    const starsContainer = document.getElementById('stars');
    for (let i = 0; i < 150; i++) {
      const star = document.createElement('div');
      star.className = 'star';
      star.style.left = Math.random() * 100 + '%';
      star.style.top = Math.random() * 100 + '%';
      star.style.animationDelay = Math.random() * 4 + 's';
      star.style.animationDuration = (3 + Math.random() * 3) + 's';
      starsContainer.appendChild(star);
    }

    async function query(q) {
      try {
        const res = await fetch(API, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${jwt}`,
          },
          body: JSON.stringify({ query: q }),
        });
        
        const data = await res.json();
        if (data.errors) throw new Error(data.errors[0].message);
        return data;
      } catch (err) {
        console.error("Query error:", err);
        throw err;
      }
    }

    function showTooltip(e, text) {
      tooltip.innerHTML = text.replace(/\\n/g, '<br>');
      tooltip.style.left = e.pageX + 15 + "px";
      tooltip.style.top = e.pageY + 15 + "px";
      tooltip.classList.add("show");
    }

    function hideTooltip() {
      tooltip.classList.remove("show");
    }

    // Safe setter ‚Äî skips if element doesn't exist
    function setText(id, val) {
      const el = document.getElementById(id);
      if (el) el.textContent = val;
    }
   function formatXP(xp) {
      if (xp >= 1000000) return (xp / 1000000).toFixed(1) + ' MB';
      if (xp >= 1000) return (xp / 1000).toFixed(0) + ' KB';
      return xp + ' B';
    }

    function drawLineChart(transactions) {
      const svg = document.getElementById("line-chart");
      const w = 900, h = 350, p = 60;

      let cumulative = 0;
      const points = transactions.map((t, i) => {
        cumulative += t.amount;
        return { x: i, y: cumulative };
      });

      const maxY = Math.max(...points.map(p => p.y)) || 1;
      const scaleX = (w - 2 * p) / (points.length - 1 || 1);
      const scaleY = (h - 2 * p) / maxY;

      let svgContent = `
        <defs>
          <linearGradient id="lineGrad" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:#a78bfa;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#ec4899;stop-opacity:1" />
          </linearGradient>
          <linearGradient id="areaGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#a78bfa;stop-opacity:0.3" />
            <stop offset="100%" style="stop-color:#a78bfa;stop-opacity:0" />
          </linearGradient>
          <filter id="glow">
            <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
            <feMerge>
              <feMergeNode in="coloredBlur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
        </defs>
      `;

      for (let i = 0; i <= 5; i++) {
        const y = p + i * (h - 2 * p) / 5;
        svgContent += `<line x1="${p}" y1="${y}" x2="${w - p}" y2="${y}" class="grid-line"/>`;
        svgContent += `<text x="${p - 10}" y="${y + 4}" class="axis-label" text-anchor="end">${formatXP(Math.round((5 - i) * maxY / 5))}</text>`;
      }

      const pathData = points.map((pt, i) => {
        const x = p + pt.x * scaleX;
        const y = h - p - pt.y * scaleY;
        return `${i === 0 ? 'M' : 'L'} ${x} ${y}`;
      }).join(' ');

      const areaPath = pathData + ` L ${w - p} ${h - p} L ${p} ${h - p} Z`;

      svgContent += `<path d="${areaPath}" fill="url(#areaGrad)"/>`;
      svgContent += `<path d="${pathData}" fill="none" stroke="url(#lineGrad)" stroke-width="3" class="line-path" filter="url(#glow)"/>`;

      points.forEach((pt, i) => {
        const x = p + pt.x * scaleX;
        const y = h - p - pt.y * scaleY;
        
        svgContent += `
          <circle cx="${x}" cy="${y}" r="5" fill="#a78bfa" opacity="0" filter="url(#glow)">
            <animate attributeName="opacity" from="0" to="1" dur="0.4s" begin="${i * 0.03}s" fill="freeze"/>
          </circle>
        `;
      });

      svg.innerHTML = svgContent;
    }

    function drawBarChart(transactions) {
      const svg = document.getElementById("bar-chart");
      const w = 900, h = 400, p = 60;

      const projectXP = {};
      transactions.forEach(t => {
        const proj = t.path.split('/').pop() || 'unknown';
        projectXP[proj] = (projectXP[proj] || 0) + t.amount;
      });

      const top10 = Object.entries(projectXP).sort((a, b) => b[1] - a[1]).slice(0, 10);
      const maxXP = Math.max(...top10.map(p => p[1])) || 1;
      const barWidth = (w - 2 * p) / top10.length - 20;
      const colors = ['#a78bfa', '#ec4899', '#8b5cf6', '#f472b6', '#c084fc', '#fb7185', '#a855f7', '#f9a8d4', '#9333ea', '#fda4af'];

      let svgContent = '';

      for (let i = 0; i <= 5; i++) {
        const y = p + i * (h - 2 * p) / 5;
        svgContent += `<line x1="${p}" y1="${y}" x2="${w - p}" y2="${y}" class="grid-line"/>`;
        svgContent += `<text x="${p - 10}" y="${y + 4}" class="axis-label" text-anchor="end">${formatXP(Math.round((5 - i) * maxXP / 5))}</text>`;
      }

      top10.forEach(([name, xp], i) => {
        const x = p + i * ((w - 2 * p) / top10.length) + 10;
        const barHeight = (xp / maxXP) * (h - 2 * p);
        const y = h - p - barHeight;
        const color = colors[i % colors.length];

        svgContent += `
          <rect class="bar-animated" x="${x}" y="${h - p}" width="${barWidth}" height="0" fill="${color}" rx="6"
            onmouseover="showTooltip(event, '${name}<br>${formatXP(xp)}')"
            onmouseout="hideTooltip()"
            style="filter: drop-shadow(0 4px 12px ${color}40);">
            <animate attributeName="height" from="0" to="${barHeight}" dur="1s" begin="${i * 0.1}s" fill="freeze"/>
            <animate attributeName="y" from="${h - p}" to="${y}" dur="1s" begin="${i * 0.1}s" fill="freeze"/>
          </rect>
          <text x="${x + barWidth / 2}" y="${h - p + 20}" text-anchor="middle" font-size="10" fill="#94a3b8">${name.substring(0, 10)}</text>
        `;
      });

      svg.innerHTML = svgContent;
    }

    function drawSpiderChart(skills, svgId, color, skillProjects) {
      const svg = document.getElementById(svgId);
      const cx = 200, cy = 200, maxRadius = 130;
      const skillNames = Object.keys(skills);
      const skillValues = Object.values(skills);
      const maxValue = Math.max(...skillValues, 1);
      const numSkills = skillNames.length;

      if (numSkills === 0) {
        svg.innerHTML = `<text x="200" y="200" text-anchor="middle" fill="#64748b" font-size="14">No data available</text>`;
        return;
      }

      let svgContent = `
        <defs>
          <linearGradient id="${svgId}Grad" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:${color};stop-opacity:0.5" />
            <stop offset="100%" style="stop-color:${color};stop-opacity:0.2" />
          </linearGradient>
        </defs>
      `;

      for (let i = 1; i <= 5; i++) {
        const r = (maxRadius / 5) * i;
        svgContent += `<circle cx="${cx}" cy="${cy}" r="${r}" fill="none" stroke="rgba(167, 139, 250, 0.08)" stroke-width="1"/>`;
      }

      const points = [];
      for (let i = 0; i < numSkills; i++) {
        const angle = (Math.PI * 2 * i) / numSkills - Math.PI / 2;
        const x = cx + Math.cos(angle) * maxRadius;
        const y = cy + Math.sin(angle) * maxRadius;
        
        svgContent += `<line x1="${cx}" y1="${cy}" x2="${x}" y2="${y}" stroke="rgba(167, 139, 250, 0.15)" stroke-width="1"/>`;
        
        const value = skillValues[i];
        const radius = (value / maxValue) * maxRadius;
        const px = cx + Math.cos(angle) * radius;
        const py = cy + Math.sin(angle) * radius;
        points.push({ x: px, y: py, name: skillNames[i], value: value });
        
        const labelRadius = maxRadius + 35;
        const lx = cx + Math.cos(angle) * labelRadius;
        const ly = cy + Math.sin(angle) * labelRadius;
        
        svgContent += `
          <text x="${lx}" y="${ly}" text-anchor="middle" font-size="11" fill="${color}" font-weight="600">
            ${skillNames[i].toUpperCase()}
          </text>
        `;
      }

      const polygonPoints = points.map(p => `${p.x},${p.y}`).join(' ');
      svgContent += `
        <polygon points="${polygonPoints}" fill="url(#${svgId}Grad)" stroke="${color}" stroke-width="2" opacity="0">
          <animate attributeName="opacity" from="0" to="1" dur="1s" fill="freeze"/>
        </polygon>
      `;

      points.forEach((point, i) => {
        const lastProject = skillProjects[point.name] || 'No recent project';
        svgContent += `
          <polygon class="skill-point" 
            points="${point.x},${point.y-6} ${point.x+5},${point.y+4} ${point.x-5},${point.y+4}"
            fill="${color}" stroke="#fff" stroke-width="1.5" opacity="0"
            onmouseover="showTooltip(event, '${point.name}: ${point.value}<br>Last used: ${lastProject}')"
            onmouseout="hideTooltip()">
            <animate attributeName="opacity" from="0" to="1" dur="0.5s" begin="${0.5 + i * 0.1}s" fill="freeze"/>
          </polygon>
        `;
      });

      svg.innerHTML = svgContent;
    }

    async function loadProfile() {
      try {
        const userQuery = `{
          user {
            id
            login
            firstName
            lastName
            email
            auditRatio
          }
        }`;
        const userData = await query(userQuery);
        const user = userData.data.user[0];
        
        console.log("=== USER DATA ===", user);

        const displayName = user.firstName 
          ? `${user.firstName} ${user.lastName || ''}`.trim() 
          : user.login;
        
        setText("user-name", displayName);

        const transactionQuery = `{
          transaction(
            where: { userId: { _eq: ${user.id} } }
            order_by: { createdAt: asc }
          ) {
            id
            type
            amount
            createdAt
            path
          }
        }`;
        const transactionData = await query(transactionQuery);
        const allTransactions = transactionData.data.transaction;
        
        console.log("=== TRANSACTIONS ===", allTransactions.length);

        // Get all paths that have skill_ transactions (completed projects)
        const skillTransactionPaths = new Set();
        allTransactions.forEach(t => {
          if (t.type.startsWith('skill_') && t.path && t.path.includes('bh-module')) {
            skillTransactionPaths.add(t.path);
          }
        });

        console.log("=== COMPLETED PROJECT PATHS ===");
        console.log([...skillTransactionPaths]);

        // Calculate Module XP: only XP from paths that have skill_ transactions
        const xpTransactions = allTransactions.filter(t => t.type === 'xp');
        const moduleXP = xpTransactions.filter(t => 
          t.path && skillTransactionPaths.has(t.path)
        ).reduce((sum, t) => sum + t.amount, 0);

        console.log("=== MODULE XP CALCULATION ===");
        console.log("Module XP (from completed projects):", moduleXP);

        setText("module-xp", formatXP(moduleXP));

        // Level: most recent level transaction + 1 to match platform display
        const levelTransactions = allTransactions
          .filter(t => t.type === 'level')
          .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
        const currentLevel = levelTransactions.length > 0 ? levelTransactions[0].amount + 1 : 0;
        setText("current-level", currentLevel);
        setText("user-level", currentLevel);
        setText("audit-ratio", user.auditRatio.toFixed(2));

        // Track skills + most recent project per skill
        const langSkills = {};
        const techSkills = {};
        const skillLastProject = {};

        const programmingLangs = ['go', 'js', 'sql', 'python', 'java', 'c', 'cpp', 'rust', 'html', 'css', 'ts'];

        allTransactions.filter(t => t.type.startsWith('skill_')).forEach(t => {
          const skillName = t.type.replace('skill_', '');
          const projectName = t.path.split('/').pop() || 'unknown';
          skillLastProject[skillName] = projectName;

          if (programmingLangs.includes(skillName.toLowerCase())) {
            langSkills[skillName] = (langSkills[skillName] || 0) + t.amount;
          } else {
            techSkills[skillName] = (techSkills[skillName] || 0) + t.amount;
          }
        });

        console.log("=== SPIDER CHART DATA (from API) ===");
        console.log("Programming Languages Graph:", langSkills);
        console.log("Technical Skills Graph:", techSkills);
        console.log("Last project per skill:", skillLastProject);
        console.log("Skills are sourced from transactions where type starts with 'skill_'");
        console.log("Languages classified:", programmingLangs);
        console.log("Raw skill transactions:", allTransactions.filter(t => t.type.startsWith('skill_')));

        drawLineChart(xpTransactions);
        drawBarChart(xpTransactions);
        drawSpiderChart(langSkills, 'spider-lang', '#a78bfa', skillLastProject);
        drawSpiderChart(techSkills, 'spider-tech', '#ec4899', skillLastProject);

        document.getElementById("loading").style.display = "none";
        document.getElementById("content").style.display = "block";
      } catch (err) {
        console.error(err);
        document.getElementById("loading").innerHTML = `
          <p style="color: #ef4444;">‚ú¶ Failed to load data</p>
          <p style="font-size: 0.9rem; color: #64748b;">${err.message}</p>
        `;
      }
    }

    function logout() {
      sessionStorage.removeItem("jwt");
      window.location.href = "index.html";
    }

    loadProfile();
  </script>
</body>
</html>
